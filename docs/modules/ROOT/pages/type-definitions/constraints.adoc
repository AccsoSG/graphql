[[type-definitions-constraints]]
= Constraints

[[type-definitions-constraints-unique]]
== Unique node property constraints

Unique node property constraints map to `@unique` directives used in your type definitions, which has the following definition:

[source, graphql, indent=0]
----
"""Informs @neo4j/graphql that there should be a uniqueness constraint in the database for the decorated field."""
directive @unique(
    """The name which should be used for this constraint. By default; type name, followed by an underscore, followed by the field name."""
    constraintName: String
) on FIELD_DEFINITION
----

Additionally, the usage of the xref::type-definitions/autogeneration.adoc#type-definitions-autogeneration-id[`@id`] directive by default implies that there should be a unique node property constraint in the database for that property.

Using this directive does not automatically ensure the existence of these constraints, and you will need to run a function on server startup. See the section xref::type-definitions/constraints.adoc#type-definitions-constraints-asserting[Asserting constraints] below for details.

=== `@unique` directive usage

`@unique` directives can only be used in GraphQL object types representing nodes, and will only be applied for the "main" label for the node. You can find some examples below.

In the following example, a unique constraint will be asserted for the label `Colour` and the property `hexadecimal`:

[source, graphql, indent=0]
----
type Colour {
    hexadecimal: String! @unique
}
----

In the next example, a unique constraint with name `unique_colour` will be asserted for the label `Colour` and the property `hexadecimal`:

[source, graphql, indent=0]
----
type Colour {
    hexadecimal: String! @unique(constraintName: "unique_colour")
}
----

The `@node` directive is used to change the database label mapping in this next example, so a unique constraint will be asserted for the label `Color` and the property `hexadecimal`:

[source, graphql, indent=0]
----
type Colour @node(label: "Color") {
    hexadecimal: String! @unique
}
----

In the following example, the `additionalLabels` argument of the `@node` directive is ignored when it comes to asserting constraints, so the outcome is the same as the example above:

[source, graphql, indent=0]
----
type Colour @node(label: "Color", additionalLabels: ["Hue"]) {
    hexadecimal: String! @unique
}
----

=== `connectOrCreate` mutations
If a related node has `@unique` directives defined, a `connectOrCreate` field can be used in a
nested xref::mutations/update.adoc[update] or xref::mutations/create.adoc[create] to perform a `MERGE` operation on the related node, creating a
relation and the related node if it doesn't exists.

Consider the following type definition:
[source, graphql, indent=0]
----
type Actor {
    name: String!
    movies: [Movie] @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}

type Movie {
    title: String
    id: String! @unique
    actors: [Actor]! @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
}
----

Because a movie id is unique, `connectOrCreate` can be used in an Actor mutation to ensure a movie exists before connecting, note that only `@unique`
parameters can be used in `where`:

[source, graphql, indent=0]
----
mutation Mutation {
  createActors(input: {
    name: "Tom Hanks",
    movies: {
      connectOrCreate: {
        where: {node: {id: "1234"}}
        onCreate: {node: {title: "Forrest Gump", id: "1234"}}
      }
    }
  }) {
    info {
      nodesCreated
    }
  }
}
----

This will ensure that a movie with id 1234 exists and it is connected to `"Tom Hanks"`. If the movie does not exists, it will be created
with the title _"Forrest Gump"_. Note that if the movie with the given id already exists, it will be connected to it, regardless of the title.

The same operation is available when updating an actor.


[[type-definitions-constraints-asserting]]
== Asserting constraints

In order to ensure that the specified constraints exist in the database, you will need to run the function `assertConstraints`, the full details of which can be found in the xref::api-reference/neo4jgraphql.adoc#api-reference-assertconstraints[API reference]. A simple example to create the necessary constraints might look like the following, assuming a valid driver instance in the variable `driver`. This will create two constraints, one for each field decorated with `@id` or `@unique`:

[source, javascript, indent=0]
----
const typeDefs = gql`
    type Colour {
        id: ID! @id
        hexadecimal: String! @unique
    }
`;

const neoSchema = new Neo4jGraphQL({ typeDefs, driver });

await neoSchema.assertConstraints({ options: { create: true }});
----
